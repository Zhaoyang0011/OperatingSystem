# Bootloader

bootloader是我们操作系统的第一步，也就是我们操作系统最先被执行的部分。为了实现bootloader，需要对平台的启动规则有一定的了解。

我把对bootloader的实现放在`src/boot`目录下。对于不同的硬件平台我们需要实现不同的bootloader。因此你可以看到boot目录下有多个子目录，每个子目录对应一个硬件平台。

## x86_64

本节对应的代码在目录src/boot/x86_64下。

### bootloader

x86平台下启动后BIOS会先做一些初始化的操作，这部分操作是由生产厂商设定的，我们不需要了解太多。初始化后，BIOS会把主引导扇区的内容加载到内存地址0x7c00处并进行跳转到0x7c00。自此，我们的操作系统就会接手整个平台。

主引导记录 (MBR: Master bootable Record) 是硬盘的引导扇区。 也就是说，它是 BIOS 在引导硬盘时加载和运行的内容。 MBR是硬盘的第一个扇区； 它包含一个 MBR 引导程序（如下所述）。

`boot.asm`是我们的第一个代码文件，也是我们操作系统的起点。它就是我们放到MBR中的引导程序。它做了三个非常简单的操作：

1. 初始化寄存器的值。
2. 读取硬盘，将我们的的二级引导器加载到内存中。
3. 加载完成后跳转到二级引导器。

### 二级引导器

由于x86平台下，bootloader只有512Byte的空间。我们很难初始化我们的kernel环境。因此，我加入了一个二级引导器来为真正的kernel进行一些初始化操作。

`setup.asm`是二级引导器的入口，bootloader最后的长跳转操作就是跳到这个文件中的代码进行执行。它做了下面几件事:

1. 调用BIOS中断，探查机器的内存信息，并储存到内存地址0x5000。
2. 进入保护模式，这样我们可以访问超过1M的内存空间了。
3. 调用set_main函数，进行kernel的数据的初始化以及将kernel加载到内存中。
4. 从set_main返回后跳转到kernel入口代码。
